free c: channel.

type host.
type pkey.
type skey.

(* Public key encryption *)

fun pk(skey): pkey.
fun aenc(bitstring, pkey): bitstring.
reduc forall x: bitstring, y: skey; adec(aenc(x,pk(y)),y) = x.

(* Agents*)
free A:host.
free B:host.
free C:host.

(* Event declaration*)
 event beginA(host,host,bitstring,bitstring).
event endB(host,host,bitstring,bitstring).

(* Security properties *)

(* query  z:bitstring,zz:bitstring; event(endB(A,B,z,zz)) ==> event(beginA(A,B,z,zz)).*)
 
free nb: bitstring [private].
query attacker (nb).

let clientA(A:host, B:host,pkA:pkey,skA:skey,pkB:pkey,n:bitstring) = 
    out(c,aenc((A,n),pkB));
    in(c,x:bitstring);
    let ((=n, nn: bitstring), =B) = adec(x,skA) in
    out(c, aenc(nn,pkB)).

let clientB(B:host,A:host,pkB:pkey,skB:skey,pkA:pkey,n:bitstring) = 
    in(c,x:bitstring); 
    let (=A,na: bitstring) = adec(x,skB) in
    out(c, aenc(((na, n), B),pkA)); 
    in(c,y:bitstring);
    if n = adec(y,skB) then 0.

 
process
	new skA:skey;
	new skB:skey;
	new skC:skey;
	let pkA= pk(skA) in out(c,pkA);
	let pkB = pk(skB) in out(c,pkB);
	let pkC = pk(skC) in out(c,skC);
(!new n:bitstring;clientA(A,B,pkA,skA,pkB,n) |
 !new n:bitstring;clientA(A,C,pkA,skA,pkC,n) |
 !new n:bitstring;clientA(B,A,pkB,skB,pkA,n) |
 !new n:bitstring;clientA(B,C,pkB,skB,pkC,n) |
 !clientB(B,A,pkB,skB,pkA,nb) |
 !new n:bitstring;clientB(B,C,pkB,skB,pkC,n) |
 !new n:bitstring;clientB(A,C,pkA,skA,pkC,n) |
 !new n:bitstring;clientB(A,B,pkA,skA,pkB,n)
 )
(*************************************************************
 *                                                           *
 *  Cryptographic protocol verifier                          *
 *                                                           *
 *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *
 *                                                           *
 *  Copyright (C) INRIA, CNRS 2000-2018                      *
 *                                                           *
 *************************************************************)

(*

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details (in file LICENSE).

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)
(* 

Needham-Schroeder public key protocol

Message 1: A -> S : (A, B)
Message 2: S -> A : { pkB, B }skS
Message 3: A -> B : { Na, A }pkB
Message 4: B -> S : (B, A)
Message 5: S -> B : { pkA, A }skS
Message 6: B -> A : { Na, Nb }pkA
Message 7: A -> B : { Nb }pkB

The heart of the protocol is messages 3, 6, 7.

*)

(* Loops if types are ignored *)
set ignoreTypes = false.

free c: channel.

type host.
type nonce.
type pkey.
type skey.
type spkey.
type sskey.

fun nonce_to_bitstring(nonce): bitstring [data,typeConverter].

(* Public key encryption *)

fun pk(skey): pkey.
fun encrypt(bitstring, pkey): bitstring.
reduc forall x: bitstring, y: skey; decrypt(encrypt(x,pk(y)),y) = x.

(* Signatures *)

fun spk(sskey): spkey.
fun sign(bitstring, sskey): bitstring.
reduc forall m: bitstring, k: sskey; getmess(sign(m,k)) = m.
reduc forall m: bitstring, k: sskey; checksign(sign(m,k), spk(k)) = m.

(* Shared key encryption *)

fun sencrypt(bitstring,nonce): bitstring.
reduc forall x: bitstring, y: nonce; sdecrypt(sencrypt(x,y),y) = x.

(* Secrecy assumptions *)

not attacker(new skA).
not attacker(new skB).
not attacker(new skS).

(* 2 honest host names A and B *)

free A, B: host.

(* the table host names/keys 
   The key table consists of pairs (host, public key) *)
table keys(host, pkey).

(* Queries *)

free secretANa, secretANb, secretBNa, secretBNb: bitstring [private].
query attacker(secretANa);
      attacker(secretANb);
      attacker(secretBNa);
      attacker(secretBNb).

event beginBparam(host, host).
event endBparam(host, host).
event beginAparam(host, host).
event endAparam(host, host).
event beginBfull(host, host, pkey, pkey, nonce, nonce).
event endBfull(host, host, pkey, pkey, nonce, nonce).
event beginAfull(host, host, pkey, pkey, nonce, nonce).
event endAfull(host, host, pkey, pkey, nonce, nonce).


query x: host, y: host; inj-event(endBparam(x,y)) ==> inj-event(beginBparam(x,y)).
query x1: host, x2: host, x3: pkey, x4: pkey, x5: nonce, x6: nonce; 
      	  inj-event(endBfull(x1,x2,x3,x4,x5,x6)) ==> inj-event(beginBfull(x1,x2,x3,x4,x5,x6)).
query x: host, y: host; inj-event(endAparam(x,y)) ==> inj-event(beginAparam(x,y)).
query x1: host, x2: host, x3: pkey, x4: pkey, x5: nonce, x6: nonce; 
      	  inj-event(endAfull(x1,x2,x3,x4,x5,x6)) ==> inj-event(beginAfull(x1,x2,x3,x4,x5,x6)).

(* Role of the initiator with identity xA and secret key skxA *)

let processInitiator(pkS: spkey, skA: skey, skB: skey) =
        (* The attacker starts the initiator by choosing identity xA,
	   and its interlocutor xB0.
	   We check that xA is honest (i.e. is A or B)
	   and get its corresponding key.
	*)
        in(c, (xA: host, hostX: host));
	if xA = A || xA = B then
	let skxA = if xA = A then skA else skB in
	let pkxA = pk(skxA) in
	(* Real start of the role *)
	event beginBparam(xA, hostX); 
	(* Message 1: Get the public key certificate for the other host *)
	out(c, (xA, hostX));
	(* Message 2 *)
	in(c, ms: bitstring); 
	let (pkX: pkey, =hostX) = checksign(ms,pkS) in
        (* Message 3 *)
	new Na: nonce; 
        out(c, encrypt((Na, xA), pkX));
        (* Message 6 *)
        in(c, m: bitstring); 
	let ((=Na, NX2: nonce),=hostX) = decrypt(m, skxA) in
	event beginBfull(xA, hostX, pkX, pkxA, Na, NX2);
        (* Message 7 *)
        out(c, encrypt(nonce_to_bitstring(NX2), pkX));
        (* OK *)
	if hostX = B || hostX = A then
	event endAparam(xA, hostX);
	event endAfull(xA, hostX, pkX, pkxA, Na, NX2);
	out(c, sencrypt(secretANa, Na));
	out(c, sencrypt(secretANb, NX2)).

(* Role of the responder with identity xB and secret key skxB *)

let processResponder(pkS: spkey, skA: skey, skB: skey) =
        (* The attacker starts the responder by choosing identity xB.
	   We check that xB is honest (i.e. is A or B). *)
        in(c, xB: host);
	if xB = A || xB = B then
	let skxB = if xB = A then skA else skB in
	let pkxB = pk(skxB) in
	(* Real start of the role *)
        (* Message 3 *)
	in(c, m: bitstring);
	let (NY: nonce, hostY: host) = decrypt(m, skxB) in
	event beginAparam(hostY, xB);
	(* Message 4: Get the public key certificate for the other host *)
        out(c, (xB, hostY));
	(* Message 5 *)
	in(c,ms: bitstring);
        let (pkY: pkey,=hostY) = checksign(ms,pkS) in
        (* Message 6 *)
	new Nb: nonce;
	event beginAfull(hostY, xB, pkxB, pkY, NY, Nb);
	out(c, encrypt(((NY, Nb),xB), pkY));
        (* Message 7 *)
	in(c, m3: bitstring);
        if nonce_to_bitstring(Nb) = decrypt(m3, skB) then
	(* OK *)
        if hostY = A || hostY = B then
	event endBparam(hostY, xB);
	event endBfull(hostY, xB, pkxB, pkY, NY, Nb);
	out(c, sencrypt(secretBNa, NY));
	out(c, sencrypt(secretBNb, Nb)).

(* Server *)

let processS(skS: sskey) =  
        in(c,(a: host, b: host)); 
	get keys(=b, sb) in
        out(c,sign((sb,b),skS)).

(* Key registration *)

let processK =
        in(c, (h: host, k: pkey));
        if h <> A && h <> B then insert keys(h,k).

(* Start process *)

process new skA: skey; 
	let pkA = pk(skA) in
        out(c, pkA);
	insert keys(A, pkA);
        new skB: skey; 
	let pkB = pk(skB) in
        out(c, pkB);
	insert keys(B, pkB);
	new skS: sskey; 
	let pkS = spk(skS) in
	out(c, pkS);
	(
          (* Launch an unbounded number of sessions of the initiator *)
          (!processInitiator(pkS, skA, skB)) | 
          (* Launch an unbounded number of sessions of the responder *)
          (!processResponder(pkS, skA, skB)) |
          (* Launch an unbounded number of sessions of the server *)
          (!processS(skS)) |
          (* Key registration process *)
	  (!processK)
        )

(*************************************************************
 *                                                           *
 *  Cryptographic protocol verifier                          *
 *                                                           *
 *  Bruno Blanchet, Vincent Cheval, and Marc Sylvestre       *
 *                                                           *
 *  Copyright (C) INRIA, CNRS 2000-2018                      *
 *                                                           *
 *************************************************************)

(*

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details (in file LICENSE).

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)
(* Needham-Schroeder shared key *)

free c: channel.

type key.
type host.
type nonce.
type tag.

(* Shared key encryption *)

fun encrypt(bitstring,key): bitstring.
reduc forall x: bitstring, y: key; decrypt(encrypt(x,y),y) = x.

(* Secrecy assumptions *)

not attacker(new Kas).
not attacker(new Kbs).

(* 2 honest host names A and B *)

free A, B: host.

(* the table host names/keys 
   The key table consists of pairs 
   (host, key shared between the host and the server) *)
table keys(host, key).

(* Queries *)

query attacker(new secretA);
      attacker(new secretB).

event endAparam(host,host).
event endBparam(host,host).
event beginAparam(host,host).
event beginBparam(host,host).
event endAkey(host, host, key).
event beginAkey(host, host, key).
event endBkey(host, host, key).
event beginBkey(host, host, key).

query x: host, y: host; inj-event(endAparam(x,y)) ==> inj-event(beginAparam(x,y)).
query x: host, y: host, z: key; inj-event(endAkey(x,y,z)) ==> inj-event(beginAkey(x,y,z)).
query x: host, y: host; inj-event(endBparam(x,y)) ==> inj-event(beginBparam(x,y)).
query x: host, y: host, z: key; inj-event(endBkey(x,y,z)) ==> inj-event(beginBkey(x,y,z)).

(* constants 0 and 1 *)

const c0: tag [data].
const c1: tag [data].


(* Role of the initiator with identity xA and key kas shared with S *)

let processInitiator =
	(* Session secret *)
	new secretA: bitstring;
        (* The attacker starts the initiator by choosing identity xA.
	   We check that xA is honest (i.e. is A or B)
	   and get its corresponding key.
	*)
        in(c, (xA: host, h: host));
	if xA = A || xA = B then
	get keys(=xA, kas) in
	(* Real start of the role *)
	event beginBparam(xA,h);
	new Na: nonce;
	out(c,(xA, (h, Na)));
	in(c,m2: bitstring);
	let (=Na, (=h, (k:key, m:bitstring))) = decrypt(m2, kas) in
	event beginBkey(xA, h, k);
	out(c,m);
	in(c, m3: bitstring);
	let ((=c0, n: nonce), =h) = decrypt(m3, k) in
	out(c, encrypt((c1, n), k));
	if h = B || h = A then
	event endAparam(xA, h);
	event endAkey(xA, h, k);
	out(c, encrypt(secretA, k)).

(* Role of the responder with identity xB and key kbs shared with S *)
                         
let processResponder =
	(* Session secret *)
	new secretB: bitstring;
        (* The attacker starts the responder by choosing identity xB.
	   We check that xB is honest (i.e. is A or B)
	   and get its corresponding key. *)
        in(c, xB: host);
	if xB = A || xB = B then
	get keys(=xB, kbs) in
	(* Real start of the role *)
	in(c,m4: bitstring);
	let (k: key,h: host) = decrypt(m4,kbs) in
	event beginAparam(h, xB);
	event beginAkey(h, xB, k);
	new Nb: nonce;
	out(c, encrypt(((c0, Nb), xB), k));
	in(c,m5: bitstring);
	let (=c1, =Nb) = decrypt(m5,k) in
	if h = A || h = B then
	event endBparam(h, xB);
	event endBkey(h, xB, k);
	out(c, encrypt(secretB, k)).

(* Server *)

let processS =
	in(c, (h1:host, (h2:host, n:nonce)));
	get keys(=h1, ks1) in
	get keys(=h2, ks2) in
	new k: key;
	out(c, encrypt((n, (h2, (k, encrypt((k,h1),ks2)))), ks1)).

(* Key registration *)

let processK =
        in(c, (h: host, k: key));
        if h <> A && h <> B then insert keys(h,k).

(* Start process *)

process
	new Kas: key; new Kbs: key;
	insert keys(A, Kas);
	insert keys(B, Kbs);
	(
          (* Launch an unbounded number of sessions of the initiator *)
          (!processInitiator) | 
          (* Launch an unbounded number of sessions of the responder *)
          (!processResponder) |
          (* Launch an unbounded number of sessions of the server *)
          (!processS) |
          (* Key registration process *)
	  (!processK)
        )

free c: channel.

type host.
type pkey.
type skey.

(* Public key encryption *)

fun pk(skey): pkey.
fun aenc(bitstring, pkey): bitstring.
reduc forall x: bitstring, y: skey; adec(aenc(x,pk(y)),y) = x.

(* Agents*)
free A:host.
free B:host.
free C:host.

(* Event declaration*)
 event beginA(host,host,bitstring,bitstring).
event endB(host,host,bitstring,bitstring).

(* Security properties *)

(* query  z:bitstring,zz:bitstring; event(endB(A,B,z,zz)) ==> event(beginA(A,B,z,zz)).*)
 
free nb: bitstring [private].
query attacker (nb).

let clientA(A:host, B:host,pkA:pkey,skA:skey,pkB:pkey,n:bitstring) = 
    out(c,aenc((A,n),pkB));
    in(c,x:bitstring);
    let ((=n, nn: bitstring), =B) = adec(x,skA) in
    out(c, aenc(nn,pkB)).

let clientB(B:host,A:host,pkB:pkey,skB:skey,pkA:pkey,n:bitstring) = 
    in(c,x:bitstring); 
    let (=A,na: bitstring) = adec(x,skB) in
    out(c, aenc(((na, n), B),pkA)); 
    in(c,y:bitstring);
    if n = adec(y,skB) then 0.

 
process
	new skA:skey;
	new skB:skey;
	new skC:skey;
	let pkA= pk(skA) in out(c,pkA);
	let pkB = pk(skB) in out(c,pkB);
	let pkC = pk(skC) in out(c,skC);
(!new n:bitstring;clientA(A,B,pkA,skA,pkB,n) |
 !new n:bitstring;clientA(A,C,pkA,skA,pkC,n) |
 !new n:bitstring;clientA(B,A,pkB,skB,pkA,n) |
 !new n:bitstring;clientA(B,C,pkB,skB,pkC,n) |
 !clientB(B,A,pkB,skB,pkA,nb) |
 !new n:bitstring;clientB(B,C,pkB,skB,pkC,n) |
 !new n:bitstring;clientB(A,C,pkA,skA,pkC,n) |
 !new n:bitstring;clientB(A,B,pkA,skA,pkB,n)
 )
