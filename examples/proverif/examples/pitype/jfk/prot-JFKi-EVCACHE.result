Linear part:
exp(exp(g,y),z) = exp(exp(g,z),y)
Completing equations...
Completed equations:
exp(exp(g,y),z) = exp(exp(g,z),y)
Convergent part:
V(S(k,v),Pk(k),v) = true
RecoverKey(S(k_1,v_1)) = Pk(k_1)
RecoverText(S(k_2,v_2)) = v_2
D(k_3,E(k_3,v_3)) = v_3
Completing equations...
Completed equations:
D(k_3,E(k_3,v_3)) = v_3
RecoverText(S(k_2,v_2)) = v_2
RecoverKey(S(k_1,v_1)) = Pk(k_1)
V(S(k,v),Pk(k),v) = true
Process 0 (that is, the initial process):
{1}new exponent: channel;
(
    {2}!
    {3}new d: texponent;
    {4}let x: G = exp(g,d) in
    {5}out(getexponential, x);
    {6}!
    {7}out(exponent, (d,x))
) | (
    {8}new honestC: channel;
    {9}!
    {10}new kAminus: skey;
    {11}let IDA: pkey = Pk(kAminus) in
    {12}new connect: channel;
    {13}new accept: channel;
    {14}new init: channel;
    {15}new channelSIA: channel;
    {16}out(getprinc, (IDA,init,accept,connect,channelSIA));
    {17}in(channelSIA, SIA: idset);
    {18}event princ(kAminus,IDA,init,accept,connect,SIA);
    (
        {19}!
        {20}out(honestC, IDA)
    ) | (
        {21}!
        {22}in(exponent, (dI: texponent,xI: G));
        {23}!
        {24}in(init, (autorid: idset,IDRp: pkey,saI: sainfo));
        {25}event initev(init,autorid,IDRp,saI);
        {26}new NI: nonce;
        {27}event mess1(IDA,NI,xI,IDRp,init,autorid,saI);
        {28}out(c, cons1(NI,xI,IDRp));
        {29}in(c, cons2(=NI,NR: nonce,xR: G,grpinfoR_1: grpinfo,IDRl: pkey,sR2: bitstring,tR: key));
        {30}event mess2rec(IDA,NI,NR,xR,grpinfoR_1,IDRl,sR2,tR,xI,IDRp,saI);
        {31}if memberid(IDRl,autorid) then
        {32}event enddosi(IDA,NI);
        {33}if (V(sR2,IDRl,(xR,grpinfoR_1)) = true) then
        {34}let h: key = exp(xR,dI) in
        {35}let Ka: key = H(h,(NI,NR,tagA)) in
        {36}let Ke: key = H(h,(NI,NR,tagE)) in
        {37}let Kv: key = H(h,(NI,NR,tagV)) in
        {38}let sI: bitstring = S(kAminus,(NI,NR,xI,xR,IDRl,saI)) in
        {39}let eI: bitstring = E(Ke,(IDA,saI,sI)) in
        {40}let hI: key = H(Ka,(constI,eI)) in
        {41}event mess3(IDA,NI,NR,xI,xR,tR,eI,hI,grpinfoR_1,IDRp,saI,Kv);
        {42}out(c, cons3(NI,NR,xI,xR,tR,eI,hI));
        {43}in(c, cons4(eR: bitstring,hR: key));
        {44}if (H(Ka,(constR,eR)) = hR) then
        {45}let (sR: bitstring,saR_1: sainfo) = D(Ke,eR) in
        {46}if (V(sR,IDRl,(NI,NR,xI,xR,IDA,saI,saR_1)) = true) then
        {47}event mess4rec(IDA,eR,hR,connect,IDRl,saI,saR_1,Kv);
        (
            {48}in(honestC, =IDRl);
            {49}event connecthonest(connect,IDRl,saI,saR_1,Kv)
        ) | (
            {50}event connectev(connect,IDRl,saI,saR_1,Kv);
            {51}out(connect, (IDRl,saI,saR_1,Kv))
        )
    ) | (
        {52}new KR: key;
        (
            {53}!
            {54}in(exponent, (dR: texponent,xR_1: G));
            {55}!
            {56}in(c, cons1(NI_1: nonce,xI_1: G,IDRp_1: pkey));
            {57}new NR_1: nonce;
            {58}let tR_1: key = H(KR,(xR_1,NR_1,NI_1)) in
            {59}event mess2(IDA,NI_1,NR_1,xI_1,xR_1,grpinfoR,S(kAminus,(xR_1,grpinfoR)),tR_1,IDRp_1);
            {60}out(c, cons2(NI_1,NR_1,xR_1,grpinfoR,IDA,S(kAminus,(xR_1,grpinfoR)),tR_1))
        ) | (
            {61}new f: channel;
            (
                {62}out(f, emptyset)
            ) | (
                {63}!
                {64}in(c, cons3(NI_2: nonce,NR_2: nonce,xI_2: G,xR_2: G,tR_2: key,eI_1: bitstring,hI_1: key));
                {65}event mess3rec(IDA,NI_2,NR_2,xI_2,xR_2,tR_2,eI_1,hI_1);
                {66}if (tR_2 = H(KR,(xR_2,NR_2,NI_2))) then
                {67}in(f, cache: keyset);
                (
                    {68}out(f, consset(tR_2,cache))
                ) | (
                    {69}if member(tR_2,cache) then
                        0
                    else
                        {70}new l: channel;
                        (
                            {71}!
                            {72}in(exponent, (dR_1: texponent,=xR_2));
                            {73}out(l, dR_1)
                        ) | (
                            {74}in(l, dR_2: texponent);
                            {75}event enddosr(IDA,NI_2,NR_2);
                            {76}let h_1: key = exp(xI_2,dR_2) in
                            {77}let Ka_1: key = H(h_1,(NI_2,NR_2,tagA)) in
                            {78}let Ke_1: key = H(h_1,(NI_2,NR_2,tagE)) in
                            {79}let Kv_1: key = H(h_1,(NI_2,NR_2,tagV)) in
                            {80}if (H(Ka_1,(constI,eI_1)) = hI_1) then
                            {81}let (IDIl: pkey,saI_1: sainfo,sI_1: bitstring) = D(Ke_1,eI_1) in
                            {82}if memberid(IDIl,SIA) then
                            {83}if (V(sI_1,IDIl,(NI_2,NR_2,xI_2,xR_2,IDA,grpinfoR)) = true) then
                            (
                                {84}in(honestC, =IDIl);
                                {85}event accepthonest(accept,IDIl,saI_1,saR,Kv_1)
                            ) | (
                                {86}event acceptev(accept,IDIl,saI_1,saR,Kv_1);
                                {87}out(accept, (IDIl,saI_1,saR,Kv_1));
                                {88}let sR_1: bitstring = S(kAminus,(NI_2,NR_2,xI_2,xR_2,IDIl,saI_1,saR)) in
                                {89}let eR_1: bitstring = E(Ke_1,(sR_1,saR)) in
                                {90}let hR_1: key = H(Ka_1,(constR,eR_1)) in
                                {91}event mess4(IDA,IDIl,eR_1,hR_1,NI_2,NR_2,xI_2,xR_2,tR_2,eI_1,hI_1);
                                {92}out(c, cons4(eR_1,hR_1))
                            )
                        )
                )
            )
        )
    )
)

Translating the process into Horn clauses...
COMPUTATIONTIME translation to clauses: 0.005828s
NUMBERIMPLIES translation to clauses: 9761
-- Query inj-event(enddosi(XIDA,XNI)) ==> (inj-event(mess2rec(XIDA,XNI,XNR,XxR,XgrpinfoR,XIDB,XsR2,XtR,XxI,XIDRp,XsaI)) ==> (inj-event(mess1(XIDA,XNI,XxI,XIDRp,XinitA,Xautorid,XsaI)) ==> inj-event(initev(XinitA,Xautorid,XIDRp,XsaI)))) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) in process 0.
nounif member(*x_1,y_1)/-5000
nounif memberid(*x_1,y_1)/-5000
Completing...
200 rules inserted. The rule base contains 187 rules. 16 rules in the queue.
nounif mess(f[SIA = *SIA_1,!1 = *@sid],cache_1)/-5000
400 rules inserted. The rule base contains 295 rules. 56 rules in the queue.
600 rules inserted. The rule base contains 317 rules. 18 rules in the queue.
COMPUTATIONTIME completion of rules: 0.205300s
NUMBERIMPLIES completion of rules: 49156
ok, secrecy assumption verified: fact unreachable attacker(kAminus[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(d[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(f[SIA = v_4,!1 = v_5])
Starting query inj-event(enddosi(XIDA,XNI)) ==> (inj-event(mess2rec(XIDA,XNI,XNR,XxR,XgrpinfoR,XIDB,XsR2,XtR,XxI,XIDRp,XsaI)) ==> (inj-event(mess1(XIDA,XNI,XxI,XIDRp,XinitA,Xautorid,XsaI)) ==> inj-event(initev(XinitA,Xautorid,XIDRp,XsaI)))) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA))
Starting query inj-event(mess2rec(Pk(kAminus[!1 = @sid]),NI[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d[!1 = @sid_2]),dI = d[!1 = @sid_2],!2 = @sid_3,SIA = SIA_1,!1 = @sid],NR_3,xR_3,grpinfoR_2,IDRl_1,sR2_1,tR_3,exp(g,d[!1 = @sid_2]),IDRp_2,saI_2)) ==> (inj-event(mess1(Pk(kAminus[!1 = @sid]),NI[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d[!1 = @sid_2]),dI = d[!1 = @sid_2],!2 = @sid_3,SIA = SIA_1,!1 = @sid],exp(g,d[!1 = @sid_2]),IDRp_2,init[!1 = @sid],Xautorid,saI_2)) ==> inj-event(initev(init[!1 = @sid],Xautorid,IDRp_2,saI_2)))
Starting query inj-event(mess1(Pk(kAminus[!1 = @sid]),NI[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d[!1 = @sid_2]),dI = d[!1 = @sid_2],!2 = @sid_3,SIA = SIA_1,!1 = @sid],exp(g,d[!1 = @sid_2]),IDRp_2,init[!1 = @sid],autorid_1,saI_2)) ==> inj-event(initev(init[!1 = @sid],autorid_1,IDRp_2,saI_2))
goal reachable: begin(initev(init_1,autorid_1,IDRp_2,saI_2),@occ25_1) && attacker(autorid_1) && attacker(IDRp_2) && attacker(saI_2) && begin(princ(kAminus_1,Pk(kAminus_1),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) -> end(@occ27_1,mess1(Pk(kAminus_1),NI_3,exp(g,d_1),IDRp_2,init_1,autorid_1,saI_2))
Abbreviations:
d_1 = d[!1 = @sid]
@occ27_1 = @occ27[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
kAminus_1 = kAminus[!1 = @sid_3]
NI_3 = NI[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
init_1 = init[!1 = @sid_3]
@occ25_1 = @occ25[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
accept_1 = accept[!1 = @sid_3]
connect_1 = connect[!1 = @sid_3]
goal reachable: attacker(NR_3) && attacker(xR_3) && attacker(grpinfoR_2) && attacker(IDRl_1) && attacker(sR2_1) && attacker(tR_3) && begin(@p_act(@occ29_1,cons2(NI_3,NR_3,xR_3,grpinfoR_2,IDRl_1,sR2_1,tR_3))) && begin(mess1(Pk(kAminus_1),NI_3,exp(g,d_1),IDRp_2,init_1,autorid_1,saI_2),@occ27_1) && begin(initev(init_1,autorid_1,IDRp_2,saI_2),@occ25_1) && attacker(autorid_1) && attacker(IDRp_2) && attacker(saI_2) && begin(princ(kAminus_1,Pk(kAminus_1),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) -> end(@occ30_1,mess2rec(Pk(kAminus_1),NI_3,NR_3,xR_3,grpinfoR_2,IDRl_1,sR2_1,tR_3,exp(g,d_1),IDRp_2,saI_2))
Abbreviations:
d_1 = d[!1 = @sid]
@occ30_1 = @occ30[tR = tR_3,sR2 = sR2_1,IDRl = IDRl_1,grpinfoR_1 = grpinfoR_2,xR = xR_3,NR = NR_3,saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
kAminus_1 = kAminus[!1 = @sid_3]
NI_3 = NI[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
@occ29_1 = @occ29[!3 = @sid_1,!2 = @sid_2,!1 = @sid_3]
init_1 = init[!1 = @sid_3]
@occ27_1 = @occ27[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
@occ25_1 = @occ25[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
accept_1 = accept[!1 = @sid_3]
connect_1 = connect[!1 = @sid_3]
goal reachable: memberid(IDRl_1,autorid_1) && begin(mess2rec(Pk(kAminus_1),NI_3,NR_3,xR_3,grpinfoR_2,IDRl_1,sR2_1,tR_3,exp(g,d_1),IDRp_2,saI_2),@occ30_1) && attacker(NR_3) && attacker(xR_3) && attacker(grpinfoR_2) && attacker(IDRl_1) && attacker(sR2_1) && attacker(tR_3) && begin(@p_act(@occ29_1,cons2(NI_3,NR_3,xR_3,grpinfoR_2,IDRl_1,sR2_1,tR_3))) && begin(mess1(Pk(kAminus_1),NI_3,exp(g,d_1),IDRp_2,init_1,autorid_1,saI_2),@occ27_1) && begin(initev(init_1,autorid_1,IDRp_2,saI_2),@occ25_1) && attacker(autorid_1) && attacker(IDRp_2) && attacker(saI_2) && begin(princ(kAminus_1,Pk(kAminus_1),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) -> end(@occ32_1,enddosi(Pk(kAminus_1),NI_3))
Abbreviations:
d_1 = d[!1 = @sid]
@occ32_1 = @occ32[tR = tR_3,sR2 = sR2_1,IDRl = IDRl_1,grpinfoR_1 = grpinfoR_2,xR = xR_3,NR = NR_3,saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
kAminus_1 = kAminus[!1 = @sid_3]
NI_3 = NI[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
@occ30_1 = @occ30[tR = tR_3,sR2 = sR2_1,IDRl = IDRl_1,grpinfoR_1 = grpinfoR_2,xR = xR_3,NR = NR_3,saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
@occ29_1 = @occ29[!3 = @sid_1,!2 = @sid_2,!1 = @sid_3]
init_1 = init[!1 = @sid_3]
@occ27_1 = @occ27[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
@occ25_1 = @occ25[saI = saI_2,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
accept_1 = accept[!1 = @sid_3]
connect_1 = connect[!1 = @sid_3]
RESULT inj-event(enddosi(XIDA,XNI)) ==> (inj-event(mess2rec(XIDA,XNI,XNR,XxR,XgrpinfoR,XIDB,XsR2,XtR,XxI,XIDRp,XsaI)) ==> (inj-event(mess1(XIDA,XNI,XxI,XIDRp,XinitA,Xautorid,XsaI)) ==> inj-event(initev(XinitA,Xautorid,XIDRp,XsaI)))) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) is true.
COMPUTATIONTIME solving_queries (include completion): 0.210132s
NUMBERIMPLIES solving_queries (include completion): 2637
Translating the process into Horn clauses...
COMPUTATIONTIME translation to clauses: 0.003132s
NUMBERIMPLIES translation to clauses: 9761
-- Query event(acceptev(XacceptB,XIDA,XsaI,XsaR,XKv)) ==> event(princ(XkBminus,XIDB,XinitB,XacceptB,XconnectB,XSIB)) && memberid(XIDA,XSIB) in process 0.
nounif member(*x_1,y_1)/-5000
nounif memberid(*x_1,y_1)/-5000
Completing...
200 rules inserted. The rule base contains 187 rules. 15 rules in the queue.
nounif mess(f[SIA = *SIA_1,!1 = *@sid],cache_1)/-5000
400 rules inserted. The rule base contains 294 rules. 62 rules in the queue.
600 rules inserted. The rule base contains 307 rules. 24 rules in the queue.
800 rules inserted. The rule base contains 346 rules. 6 rules in the queue.
COMPUTATIONTIME completion of rules: 0.152933s
NUMBERIMPLIES completion of rules: 49343
ok, secrecy assumption verified: fact unreachable attacker(kAminus[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(d[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(f[SIA = v_4,!1 = v_5])
Starting query event(acceptev(XacceptB,XIDA,XsaI,XsaR,XKv)) ==> event(princ(XkBminus,XIDB,XinitB,XacceptB,XconnectB,XSIB)) && memberid(XIDA,XSIB)
goal reachable: memberid(Pk(k_4),SIA_1) && attacker(XsaI) && attacker(k_4) && attacker(NI_3) && attacker(xI_3) && attacker(IDRp_2) && attacker(y_1) && begin(princ(kAminus_1,Pk(kAminus_1),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) -> end(acceptev(accept_1,Pk(k_4),XsaI,saR,H(exp(exp(g,d_1),y_1),(NI_3,NR_3,tagV))))
Abbreviations:
accept_1 = accept[!1 = @sid]
d_1 = d[!1 = @sid_1]
NR_3 = NR_1[IDRp_1 = IDRp_2,xI_1 = xI_3,NI_1 = NI_3,!3 = @sid_2,xR_1 = exp(g,d_1),dR = d_1,!2 = @sid_3,SIA = SIA_1,!1 = @sid]
kAminus_1 = kAminus[!1 = @sid]
init_1 = init[!1 = @sid]
connect_1 = connect[!1 = @sid]
goal reachable: memberid(Pk(k_4),SIA_1) && attacker(XsaI) && attacker(k_4) && attacker(NI_3) && attacker(xI_3) && attacker(IDRp_2) && begin(princ(kAminus_1,Pk(kAminus_1),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) -> end(acceptev(accept_1,Pk(k_4),XsaI,saR,H(exp(g,d_1),(NI_3,NR_3,tagV))))
Abbreviations:
accept_1 = accept[!1 = @sid]
d_1 = d[!1 = @sid_1]
NR_3 = NR_1[IDRp_1 = IDRp_2,xI_1 = xI_3,NI_1 = NI_3,!3 = @sid_2,xR_1 = exp(g,d_1),dR = d_1,!2 = @sid_3,SIA = SIA_1,!1 = @sid]
kAminus_1 = kAminus[!1 = @sid]
init_1 = init[!1 = @sid]
connect_1 = connect[!1 = @sid]
goal reachable: memberid(Pk(kAminus_1),SIA_1) && mess(f_1,cache_1) && memberid(Pk(kAminus_2),autorid_1) && attacker(xI_3) && attacker(IDRp_2) && attacker(autorid_1) && attacker(IDRp_3) && begin(princ(kAminus_1,Pk(kAminus_1),init_1,accept_1,connect_1,SIA_2)) && attacker(SIA_2) && begin(princ(kAminus_2,Pk(kAminus_2),init_2,accept_2,connect_2,SIA_1)) && attacker(SIA_1) -> end(acceptev(accept_2,Pk(kAminus_1),grpinfoR[],saR,H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagV))))
Abbreviations:
accept_2 = accept[!1 = @sid]
kAminus_1 = kAminus[!1 = @sid_1]
d_1 = d[!1 = @sid_2]
d_2 = d[!1 = @sid_3]
NI_3 = NI[saI = grpinfoR[],IDRp = IDRp_3,autorid = autorid_1,!3 = @sid_4,xI = exp(g,d_1),dI = d_1,!2 = @sid_5,SIA = SIA_2,!1 = @sid_1]
NR_3 = NR_1[IDRp_1 = IDRp_2,xI_1 = xI_3,NI_1 = NI_3,!3 = @sid_6,xR_1 = exp(g,d_2),dR = d_2,!2 = @sid_7,SIA = SIA_1,!1 = @sid]
f_1 = f[SIA = SIA_1,!1 = @sid]
kAminus_2 = kAminus[!1 = @sid]
init_1 = init[!1 = @sid_1]
accept_1 = accept[!1 = @sid_1]
connect_1 = connect[!1 = @sid_1]
init_2 = init[!1 = @sid]
connect_2 = connect[!1 = @sid]
RESULT event(acceptev(XacceptB,XIDA,XsaI,XsaR,XKv)) ==> event(princ(XkBminus,XIDB,XinitB,XacceptB,XconnectB,XSIB)) && memberid(XIDA,XSIB) is true.
COMPUTATIONTIME solving_queries (include completion): 0.156540s
NUMBERIMPLIES solving_queries (include completion): 2600
Translating the process into Horn clauses...
COMPUTATIONTIME translation to clauses: 0.004897s
NUMBERIMPLIES translation to clauses: 9761
-- Query inj-event(connectev(XconnectA,XIDB,XsaI,XsaR,XKv)) ==> inj-event(initev(XinitA,Xautorid,XIDRp,XsaI)) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) && memberid(XIDB,Xautorid) in process 0.
nounif member(*x_1,y_1)/-5000
nounif memberid(*x_1,y_1)/-5000
Completing...
200 rules inserted. The rule base contains 185 rules. 20 rules in the queue.
nounif mess(f[SIA = *SIA_1,!1 = *@sid],cache_1)/-5000
400 rules inserted. The rule base contains 293 rules. 50 rules in the queue.
600 rules inserted. The rule base contains 316 rules. 18 rules in the queue.
800 rules inserted. The rule base contains 348 rules. 7 rules in the queue.
COMPUTATIONTIME completion of rules: 0.208409s
NUMBERIMPLIES completion of rules: 49835
ok, secrecy assumption verified: fact unreachable attacker(kAminus[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(d[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(f[SIA = v_4,!1 = v_5])
Starting query inj-event(connectev(XconnectA,XIDB,XsaI,XsaR,XKv)) ==> inj-event(initev(XinitA,Xautorid,XIDRp,XsaI)) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) && memberid(XIDB,Xautorid)
goal reachable: memberid(Pk(kAminus_1),SIA_1) && mess(f_1,cache_1) && begin(@p_act(@occ43_2,cons4(E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(S(kAminus_2,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_1),grpinfoR[],saR)),saR)),H(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagA)),(constR,E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(S(kAminus_2,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_1),grpinfoR[],saR)),saR))))))) && memberid(Pk(kAminus_2),autorid_1) && attacker(xI_3) && attacker(IDRp_2) && begin(princ(kAminus_2,Pk(kAminus_2),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) && attacker(tR_3) && begin(@p_act(@occ29_2,cons2(NI_3,NR_3,exp(g,d_2),grpinfoR[],Pk(kAminus_2),S(kAminus_2,(exp(g,d_2),grpinfoR[])),tR_3))) && begin(initev(init_2,autorid_1,IDRp_3,grpinfoR[]),@occ25_2) && attacker(autorid_1) && attacker(IDRp_3) && begin(princ(kAminus_1,Pk(kAminus_1),init_2,accept_2,connect_2,SIA_2)) && attacker(SIA_2) -> end(@occ50_1,connectev(connect_2,Pk(kAminus_2),grpinfoR[],saR,H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagV))))
Abbreviations:
d_1 = d[!1 = @sid]
d_2 = d[!1 = @sid_1]
NI_3 = NI[saI = grpinfoR[],IDRp = IDRp_3,autorid = autorid_1,!3 = @sid_2,xI = exp(g,d_1),dI = d_1,!2 = @sid_3,SIA = SIA_2,!1 = @sid_4]
NR_3 = NR_1[IDRp_1 = IDRp_2,xI_1 = xI_3,NI_1 = NI_3,!3 = @sid_5,xR_1 = exp(g,d_2),dR = d_2,!2 = @sid_6,SIA = SIA_1,!1 = @sid_7]
kAminus_2 = kAminus[!1 = @sid_7]
kAminus_1 = kAminus[!1 = @sid_4]
@occ50_1 = @occ50[hR = H(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagA)),(constR,E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(S(kAminus_2,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_1),grpinfoR[],saR)),saR)))),eR = E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(S(kAminus_2,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_1),grpinfoR[],saR)),saR)),tR = tR_3,sR2 = S(kAminus_2,(exp(g,d_2),grpinfoR[])),IDRl = Pk(kAminus_2),grpinfoR_1 = grpinfoR[],xR = exp(g,d_2),NR = NR_3,saI = grpinfoR[],IDRp = IDRp_3,autorid = autorid_1,!3 = @sid_2,xI = exp(g,d_1),dI = d_1,!2 = @sid_3,SIA = SIA_2,!1 = @sid_4]
connect_2 = connect[!1 = @sid_4]
f_1 = f[SIA = SIA_1,!1 = @sid_7]
@occ43_2 = @occ43_1[!3 = @sid_2,!2 = @sid_3,!1 = @sid_4]
init_1 = init[!1 = @sid_7]
accept_1 = accept[!1 = @sid_7]
connect_1 = connect[!1 = @sid_7]
@occ29_2 = @occ29_1[!3 = @sid_2,!2 = @sid_3,!1 = @sid_4]
init_2 = init[!1 = @sid_4]
@occ25_2 = @occ25_1[saI = grpinfoR[],IDRp = IDRp_3,autorid = autorid_1,!3 = @sid_2,xI = exp(g,d_1),dI = d_1,!2 = @sid_3,SIA = SIA_2,!1 = @sid_4]
accept_2 = accept[!1 = @sid_4]
goal reachable: attacker(XsaR) && begin(@p_act(@occ43_2,cons4(E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(k_4,(NI_3,NR_3,exp(g,d_1),exp(g,z_1),Pk(kAminus_1),XsaI,XsaR)),XsaR)),H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constR,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(k_4,(NI_3,NR_3,exp(g,d_1),exp(g,z_1),Pk(kAminus_1),XsaI,XsaR)),XsaR))))))) && memberid(Pk(k_4),autorid_1) && attacker(NR_3) && attacker(k_4) && attacker(z_1) && attacker(grpinfoR_2) && attacker(tR_3) && begin(@p_act(@occ29_2,cons2(NI_3,NR_3,exp(g,z_1),grpinfoR_2,Pk(k_4),S(k_4,(exp(g,z_1),grpinfoR_2)),tR_3))) && begin(initev(init_1,autorid_1,IDRp_2,XsaI),@occ25_2) && attacker(autorid_1) && attacker(IDRp_2) && attacker(XsaI) && begin(princ(kAminus_1,Pk(kAminus_1),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) -> end(@occ50_1,connectev(connect_1,Pk(k_4),XsaI,XsaR,H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagV))))
Abbreviations:
d_1 = d[!1 = @sid]
NI_3 = NI[saI = XsaI,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
kAminus_1 = kAminus[!1 = @sid_3]
@occ50_1 = @occ50[hR = H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constR,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(k_4,(NI_3,NR_3,exp(g,d_1),exp(g,z_1),Pk(kAminus_1),XsaI,XsaR)),XsaR)))),eR = E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(k_4,(NI_3,NR_3,exp(g,d_1),exp(g,z_1),Pk(kAminus_1),XsaI,XsaR)),XsaR)),tR = tR_3,sR2 = S(k_4,(exp(g,z_1),grpinfoR_2)),IDRl = Pk(k_4),grpinfoR_1 = grpinfoR_2,xR = exp(g,z_1),NR = NR_3,saI = XsaI,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
connect_1 = connect[!1 = @sid_3]
@occ43_2 = @occ43_1[!3 = @sid_1,!2 = @sid_2,!1 = @sid_3]
@occ29_2 = @occ29_1[!3 = @sid_1,!2 = @sid_2,!1 = @sid_3]
init_1 = init[!1 = @sid_3]
@occ25_2 = @occ25_1[saI = XsaI,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
accept_1 = accept[!1 = @sid_3]
goal reachable: attacker(XsaR) && begin(@p_act(@occ43_2,cons4(E(H(exp(g,d_1),(NI_3,NR_3,tagE)),(S(k_4,(NI_3,NR_3,exp(g,d_1),g,Pk(kAminus_1),XsaI,XsaR)),XsaR)),H(H(exp(g,d_1),(NI_3,NR_3,tagA)),(constR,E(H(exp(g,d_1),(NI_3,NR_3,tagE)),(S(k_4,(NI_3,NR_3,exp(g,d_1),g,Pk(kAminus_1),XsaI,XsaR)),XsaR))))))) && memberid(Pk(k_4),autorid_1) && attacker(NR_3) && attacker(k_4) && attacker(grpinfoR_2) && attacker(tR_3) && begin(@p_act(@occ29_2,cons2(NI_3,NR_3,g,grpinfoR_2,Pk(k_4),S(k_4,(g,grpinfoR_2)),tR_3))) && begin(initev(init_1,autorid_1,IDRp_2,XsaI),@occ25_2) && attacker(autorid_1) && attacker(IDRp_2) && attacker(XsaI) && begin(princ(kAminus_1,Pk(kAminus_1),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) -> end(@occ50_1,connectev(connect_1,Pk(k_4),XsaI,XsaR,H(exp(g,d_1),(NI_3,NR_3,tagV))))
Abbreviations:
d_1 = d[!1 = @sid]
NI_3 = NI[saI = XsaI,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
kAminus_1 = kAminus[!1 = @sid_3]
@occ50_1 = @occ50[hR = H(H(exp(g,d_1),(NI_3,NR_3,tagA)),(constR,E(H(exp(g,d_1),(NI_3,NR_3,tagE)),(S(k_4,(NI_3,NR_3,exp(g,d_1),g,Pk(kAminus_1),XsaI,XsaR)),XsaR)))),eR = E(H(exp(g,d_1),(NI_3,NR_3,tagE)),(S(k_4,(NI_3,NR_3,exp(g,d_1),g,Pk(kAminus_1),XsaI,XsaR)),XsaR)),tR = tR_3,sR2 = S(k_4,(g,grpinfoR_2)),IDRl = Pk(k_4),grpinfoR_1 = grpinfoR_2,xR = g,NR = NR_3,saI = XsaI,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
connect_1 = connect[!1 = @sid_3]
@occ43_2 = @occ43_1[!3 = @sid_1,!2 = @sid_2,!1 = @sid_3]
@occ29_2 = @occ29_1[!3 = @sid_1,!2 = @sid_2,!1 = @sid_3]
init_1 = init[!1 = @sid_3]
@occ25_2 = @occ25_1[saI = XsaI,IDRp = IDRp_2,autorid = autorid_1,!3 = @sid_1,xI = exp(g,d_1),dI = d_1,!2 = @sid_2,SIA = SIA_1,!1 = @sid_3]
accept_1 = accept[!1 = @sid_3]
RESULT inj-event(connectev(XconnectA,XIDB,XsaI,XsaR,XKv)) ==> inj-event(initev(XinitA,Xautorid,XIDRp,XsaI)) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) && memberid(XIDB,Xautorid) is true.
COMPUTATIONTIME solving_queries (include completion): 0.215168s
NUMBERIMPLIES solving_queries (include completion): 2648
Translating the process into Horn clauses...
COMPUTATIONTIME translation to clauses: 0.004198s
NUMBERIMPLIES translation to clauses: 9761
-- Query inj-event(connecthonest(XconnectA,XIDB,XsaI,XsaR,XKv)) ==> inj-event(acceptev(XacceptB,XIDA,XsaI,XsaR,XKv)) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) && event(princ(XkBminus,XIDB,XinitB,XacceptB,XconnectB,XSIB)) in process 0.
nounif member(*x_1,y_1)/-5000
nounif memberid(*x_1,y_1)/-5000
Completing...
200 rules inserted. The rule base contains 185 rules. 20 rules in the queue.
nounif mess(f[SIA = *SIA_1,!1 = *@sid],cache_1)/-5000
400 rules inserted. The rule base contains 297 rules. 49 rules in the queue.
600 rules inserted. The rule base contains 334 rules. 30 rules in the queue.
800 rules inserted. The rule base contains 363 rules. 48 rules in the queue.
1000 rules inserted. The rule base contains 402 rules. 18 rules in the queue.
COMPUTATIONTIME completion of rules: 0.329585s
NUMBERIMPLIES completion of rules: 71846
ok, secrecy assumption verified: fact unreachable attacker(kAminus[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(d[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(f[SIA = v_4,!1 = v_5])
Starting query inj-event(connecthonest(XconnectA,XIDB,XsaI,XsaR,XKv)) ==> inj-event(acceptev(XacceptB,XIDA,XsaI,XsaR,XKv)) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) && event(princ(XkBminus,XIDB,XinitB,XacceptB,XconnectB,XSIB))
goal reachable: begin(acceptev(accept_1,Pk(kAminus_1),grpinfoR[],saR,H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagV))),@occ86_1) && memberid(Pk(kAminus_1),SIA_1) && memberid(Pk(kAminus_2),autorid_1) && attacker(xI_3) && attacker(IDRp_2) && begin(princ(kAminus_2,Pk(kAminus_2),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) && attacker(tR_3) && attacker(autorid_1) && attacker(IDRp_3) && begin(princ(kAminus_1,Pk(kAminus_1),init_2,accept_2,connect_2,SIA_2)) && attacker(SIA_2) -> end(@occ49_1,connecthonest(connect_2,Pk(kAminus_2),grpinfoR[],saR,H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagV))))
Abbreviations:
d_1 = d[!1 = @sid]
d_2 = d[!1 = @sid_1]
NI_3 = NI[saI = grpinfoR[],IDRp = IDRp_3,autorid = autorid_1,!3 = @sid_2,xI = exp(g,d_1),dI = d_1,!2 = @sid_3,SIA = SIA_2,!1 = @sid_4]
NR_3 = NR_1[IDRp_1 = IDRp_2,xI_1 = xI_3,NI_1 = NI_3,!3 = @sid_5,xR_1 = exp(g,d_2),dR = d_2,!2 = @sid_6,SIA = SIA_1,!1 = @sid_7]
kAminus_2 = kAminus[!1 = @sid_7]
kAminus_1 = kAminus[!1 = @sid_4]
@occ49_1 = @occ49[hR = H(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagA)),(constR,E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(S(kAminus_2,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_1),grpinfoR[],saR)),saR)))),eR = E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(S(kAminus_2,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_1),grpinfoR[],saR)),saR)),tR = tR_3,sR2 = S(kAminus_2,(exp(g,d_2),grpinfoR[])),IDRl = Pk(kAminus_2),grpinfoR_1 = grpinfoR[],xR = exp(g,d_2),NR = NR_3,saI = grpinfoR[],IDRp = IDRp_3,autorid = autorid_1,!3 = @sid_2,xI = exp(g,d_1),dI = d_1,!2 = @sid_3,SIA = SIA_2,!1 = @sid_4]
connect_2 = connect[!1 = @sid_4]
accept_1 = accept[!1 = @sid_7]
KR_1 = KR[SIA = SIA_1,!1 = @sid_7]
@occ86_1 = @occ86[dR_2 = d_2,cache = emptyset,hI_1 = H(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(Pk(kAminus_1),grpinfoR[],S(kAminus_1,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_2),grpinfoR[])))))),eI_1 = E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(Pk(kAminus_1),grpinfoR[],S(kAminus_1,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_2),grpinfoR[])))),tR_2 = H(KR_1,(exp(g,d_2),NR_3,NI_3)),xR_2 = exp(g,d_2),xI_2 = exp(g,d_1),NR_2 = NR_3,NI_2 = NI_3,!2 = @sid_8,SIA = SIA_1,!1 = @sid_7]
init_1 = init[!1 = @sid_7]
connect_1 = connect[!1 = @sid_7]
init_2 = init[!1 = @sid_4]
accept_2 = accept[!1 = @sid_4]
goal reachable: begin(acceptev(accept_1,Pk(kAminus_1),grpinfoR[],saR,H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagV))),@occ86_1) && memberid(Pk(kAminus_1),SIA_1) && mess(f_1,cache_1) && attacker(NI_4) && attacker(xI_3) && attacker(IDRp_2) && memberid(Pk(kAminus_2),autorid_1) && attacker(xI_4) && attacker(IDRp_3) && begin(princ(kAminus_2,Pk(kAminus_2),init_1,accept_1,connect_1,SIA_1)) && attacker(SIA_1) && attacker(tR_3) && attacker(autorid_1) && attacker(IDRp_4) && begin(princ(kAminus_1,Pk(kAminus_1),init_2,accept_2,connect_2,SIA_2)) && attacker(SIA_2) -> end(@occ49_1,connecthonest(connect_2,Pk(kAminus_2),grpinfoR[],saR,H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagV))))
Abbreviations:
d_1 = d[!1 = @sid]
d_2 = d[!1 = @sid_1]
NI_3 = NI[saI = grpinfoR[],IDRp = IDRp_4,autorid = autorid_1,!3 = @sid_2,xI = exp(g,d_1),dI = d_1,!2 = @sid_3,SIA = SIA_2,!1 = @sid_4]
NR_3 = NR_1[IDRp_1 = IDRp_3,xI_1 = xI_4,NI_1 = NI_3,!3 = @sid_5,xR_1 = exp(g,d_2),dR = d_2,!2 = @sid_6,SIA = SIA_1,!1 = @sid_7]
kAminus_2 = kAminus[!1 = @sid_7]
kAminus_1 = kAminus[!1 = @sid_4]
@occ49_1 = @occ49[hR = H(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagA)),(constR,E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(S(kAminus_2,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_1),grpinfoR[],saR)),saR)))),eR = E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(S(kAminus_2,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_1),grpinfoR[],saR)),saR)),tR = tR_3,sR2 = S(kAminus_2,(exp(g,d_2),grpinfoR[])),IDRl = Pk(kAminus_2),grpinfoR_1 = grpinfoR[],xR = exp(g,d_2),NR = NR_3,saI = grpinfoR[],IDRp = IDRp_4,autorid = autorid_1,!3 = @sid_2,xI = exp(g,d_1),dI = d_1,!2 = @sid_3,SIA = SIA_2,!1 = @sid_4]
connect_2 = connect[!1 = @sid_4]
accept_1 = accept[!1 = @sid_7]
KR_1 = KR[SIA = SIA_1,!1 = @sid_7]
d_3 = d[!1 = @sid_8]
NR_4 = NR_1[IDRp_1 = IDRp_2,xI_1 = xI_3,NI_1 = NI_4,!3 = @sid_9,xR_1 = exp(g,d_3),dR = d_3,!2 = @sid_10,SIA = SIA_1,!1 = @sid_7]
@occ86_1 = @occ86[dR_2 = d_2,cache = consset(H(KR_1,(exp(g,d_3),NR_4,NI_4)),cache_1),hI_1 = H(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(Pk(kAminus_1),grpinfoR[],S(kAminus_1,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_2),grpinfoR[])))))),eI_1 = E(H(exp(exp(g,d_1),d_2),(NI_3,NR_3,tagE)),(Pk(kAminus_1),grpinfoR[],S(kAminus_1,(NI_3,NR_3,exp(g,d_1),exp(g,d_2),Pk(kAminus_2),grpinfoR[])))),tR_2 = H(KR_1,(exp(g,d_2),NR_3,NI_3)),xR_2 = exp(g,d_2),xI_2 = exp(g,d_1),NR_2 = NR_3,NI_2 = NI_3,!2 = @sid_11,SIA = SIA_1,!1 = @sid_7]
f_1 = f[SIA = SIA_1,!1 = @sid_7]
init_1 = init[!1 = @sid_7]
connect_1 = connect[!1 = @sid_7]
init_2 = init[!1 = @sid_4]
accept_2 = accept[!1 = @sid_4]
RESULT inj-event(connecthonest(XconnectA,XIDB,XsaI,XsaR,XKv)) ==> inj-event(acceptev(XacceptB,XIDA,XsaI,XsaR,XKv)) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) && event(princ(XkBminus,XIDB,XinitB,XacceptB,XconnectB,XSIB)) is true.
COMPUTATIONTIME solving_queries (include completion): 0.335653s
NUMBERIMPLIES solving_queries (include completion): 2599
Translating the process into Horn clauses...
COMPUTATIONTIME translation to clauses: 0.002952s
NUMBERIMPLIES translation to clauses: 9761
-- Query not attacker(S(kAminus[!1 = v_4],x_1)) in process 0.
nounif member(*x_1,y_1)/-5000
nounif memberid(*x_1,y_1)/-5000
Completing...
200 rules inserted. The rule base contains 185 rules. 11 rules in the queue.
nounif mess(f[SIA = *SIA_1,!1 = *@sid],cache_1)/-5000
400 rules inserted. The rule base contains 283 rules. 38 rules in the queue.
600 rules inserted. The rule base contains 300 rules. 19 rules in the queue.
COMPUTATIONTIME completion of rules: 0.114054s
NUMBERIMPLIES completion of rules: 48444
ok, secrecy assumption verified: fact unreachable attacker(kAminus[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(d[!1 = v_4])
ok, secrecy assumption verified: fact unreachable attacker(f[SIA = v_4,!1 = v_5])
Starting query not attacker(S(kAminus[!1 = v_4],x_1))
goal reachable: memberid(Pk(k_4),SIA_1) && attacker(saI_2) && attacker(k_4) && attacker(NI_3) && attacker(xI_3) && attacker(IDRp_2) && attacker(z_1) && attacker(SIA_1) -> attacker(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)))
Abbreviations:
kAminus_1 = kAminus[!1 = @sid]
d_1 = d[!1 = @sid_1]
NR_3 = NR_1[IDRp_1 = IDRp_2,xI_1 = xI_3,NI_1 = NI_3,!3 = @sid_2,xR_1 = exp(g,d_1),dR = d_1,!2 = @sid_3,SIA = SIA_1,!1 = @sid]

Derivation:
Abbreviations:
kAminus_1 = kAminus[!1 = @sid]
d_1 = d[!1 = @sid_1]
NR_3 = NR_1[IDRp_1 = IDRp_2,xI_1 = xI_3,NI_1 = NI_3,!3 = @sid_2,xR_1 = exp(g,d_1),dR = d_1,!2 = @sid_3,SIA = SIA_1,!1 = @sid]
KR_1 = KR[SIA = SIA_1,!1 = @sid]
l_1 = l[cache = emptyset,hI_1 = H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))))),eI_1 = E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))),tR_2 = H(KR_1,(exp(g,d_1),NR_3,NI_3)),xR_2 = exp(g,d_1),xI_2 = exp(g,z_1),NR_2 = NR_3,NI_2 = NI_3,!2 = @sid_4,SIA = SIA_1,!1 = @sid]
f_1 = f[SIA = SIA_1,!1 = @sid]
channelSIA_1 = channelSIA[!1 = @sid]
init_1 = init[!1 = @sid]
accept_1 = accept[!1 = @sid]
connect_1 = connect[!1 = @sid]

1. We assume as hypothesis that
attacker(SIA_1).

2. The message (Pk(kAminus_1),init_1,accept_1,connect_1,channelSIA_1) may be sent to the attacker at output {16}.
attacker((Pk(kAminus_1),init_1,accept_1,connect_1,channelSIA_1)).

3. By 2, the attacker may know (Pk(kAminus_1),init_1,accept_1,connect_1,channelSIA_1).
Using the function 5-proj-5-tuple the attacker may obtain channelSIA_1.
attacker(channelSIA_1).

4. By 3, the attacker may have the channel channelSIA_1.
By 1, the attacker may have the message SIA_1.
So the attacker may send this message on this channel.
mess(channelSIA_1,SIA_1).

5. The attacker initially knows grpinfoR[].
attacker(grpinfoR[]).

6. By 2, the attacker may know (Pk(kAminus_1),init_1,accept_1,connect_1,channelSIA_1).
Using the function 1-proj-5-tuple the attacker may obtain Pk(kAminus_1).
attacker(Pk(kAminus_1)).

7. The message exp(g,d_1) may be sent to the attacker at output {5}.
attacker(exp(g,d_1)).

8. We assume as hypothesis that
attacker(z_1).

9. Using the function g the attacker may obtain g.
attacker(g).

10. By 9, the attacker may know g.
By 8, the attacker may know z_1.
Using the function exp the attacker may obtain exp(g,z_1).
attacker(exp(g,z_1)).

11. The message (d_1,exp(g,d_1)) may be sent on channel exponent[] at output {7}.
mess(exponent[],(d_1,exp(g,d_1))).

12. We assume as hypothesis that
attacker(IDRp_2).

13. We assume as hypothesis that
attacker(xI_3).

14. We assume as hypothesis that
attacker(NI_3).

15. By 14, the attacker may know NI_3.
By 13, the attacker may know xI_3.
By 12, the attacker may know IDRp_2.
Using the function cons1 the attacker may obtain cons1(NI_3,xI_3,IDRp_2).
attacker(cons1(NI_3,xI_3,IDRp_2)).

16. The message SIA_1 that may be sent on channel channelSIA_1 by 4 may be received at input {17}.
The message (d_1,exp(g,d_1)) that may be sent on channel exponent[] by 11 may be received at input {54}.
The message cons1(NI_3,xI_3,IDRp_2) that the attacker may have by 15 may be received at input {56}.
So the message cons2(NI_3,NR_3,exp(g,d_1),grpinfoR[],Pk(kAminus_1),S(kAminus_1,(exp(g,d_1),grpinfoR[])),H(KR_1,(exp(g,d_1),NR_3,NI_3))) may be sent to the attacker at output {60}.
attacker(cons2(NI_3,NR_3,exp(g,d_1),grpinfoR[],Pk(kAminus_1),S(kAminus_1,(exp(g,d_1),grpinfoR[])),H(KR_1,(exp(g,d_1),NR_3,NI_3)))).

17. By 16, the attacker may know cons2(NI_3,NR_3,exp(g,d_1),grpinfoR[],Pk(kAminus_1),S(kAminus_1,(exp(g,d_1),grpinfoR[])),H(KR_1,(exp(g,d_1),NR_3,NI_3))).
Using the function 2-proj-cons2 the attacker may obtain NR_3.
attacker(NR_3).

18. By 14, the attacker may know NI_3.
By 17, the attacker may know NR_3.
By 10, the attacker may know exp(g,z_1).
By 7, the attacker may know exp(g,d_1).
By 6, the attacker may know Pk(kAminus_1).
By 5, the attacker may know grpinfoR[].
Using the function 6-tuple the attacker may obtain (NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]).
attacker((NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])).

19. We assume as hypothesis that
attacker(k_4).

20. By 19, the attacker may know k_4.
By 18, the attacker may know (NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]).
Using the function S the attacker may obtain S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])).
attacker(S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))).

21. We assume as hypothesis that
attacker(saI_2).

22. By 19, the attacker may know k_4.
Using the function Pk the attacker may obtain Pk(k_4).
attacker(Pk(k_4)).

23. By 22, the attacker may know Pk(k_4).
By 21, the attacker may know saI_2.
By 20, the attacker may know S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])).
Using the function 3-tuple the attacker may obtain (Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))).
attacker((Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))).

24. Using the function tagE the attacker may obtain tagE.
attacker(tagE).

25. By 14, the attacker may know NI_3.
By 17, the attacker may know NR_3.
By 24, the attacker may know tagE.
Using the function 3-tuple the attacker may obtain (NI_3,NR_3,tagE).
attacker((NI_3,NR_3,tagE)).

26. By 7, the attacker may know exp(g,d_1).
By 8, the attacker may know z_1.
Using the function exp the attacker may obtain exp(exp(g,z_1),d_1).
attacker(exp(exp(g,z_1),d_1)).

27. By 26, the attacker may know exp(exp(g,z_1),d_1).
By 25, the attacker may know (NI_3,NR_3,tagE).
Using the function H the attacker may obtain H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)).
attacker(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE))).

28. By 27, the attacker may know H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)).
By 23, the attacker may know (Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))).
Using the function E the attacker may obtain E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))).
attacker(E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))))).

29. Using the function constI the attacker may obtain constI.
attacker(constI).

30. By 29, the attacker may know constI.
By 28, the attacker may know E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))).
Using the function 2-tuple the attacker may obtain (constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))))).
attacker((constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))))).

31. Using the function tagA the attacker may obtain tagA.
attacker(tagA).

32. By 14, the attacker may know NI_3.
By 17, the attacker may know NR_3.
By 31, the attacker may know tagA.
Using the function 3-tuple the attacker may obtain (NI_3,NR_3,tagA).
attacker((NI_3,NR_3,tagA)).

33. By 26, the attacker may know exp(exp(g,z_1),d_1).
By 32, the attacker may know (NI_3,NR_3,tagA).
Using the function H the attacker may obtain H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)).
attacker(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA))).

34. By 33, the attacker may know H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)).
By 30, the attacker may know (constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))))).
Using the function H the attacker may obtain H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))))).
attacker(H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))))))).

35. By 16, the attacker may know cons2(NI_3,NR_3,exp(g,d_1),grpinfoR[],Pk(kAminus_1),S(kAminus_1,(exp(g,d_1),grpinfoR[])),H(KR_1,(exp(g,d_1),NR_3,NI_3))).
Using the function 7-proj-cons2 the attacker may obtain H(KR_1,(exp(g,d_1),NR_3,NI_3)).
attacker(H(KR_1,(exp(g,d_1),NR_3,NI_3))).

36. By 14, the attacker may know NI_3.
By 17, the attacker may know NR_3.
By 10, the attacker may know exp(g,z_1).
By 7, the attacker may know exp(g,d_1).
By 35, the attacker may know H(KR_1,(exp(g,d_1),NR_3,NI_3)).
By 28, the attacker may know E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))).
By 34, the attacker may know H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))))).
Using the function cons3 the attacker may obtain cons3(NI_3,NR_3,exp(g,z_1),exp(g,d_1),H(KR_1,(exp(g,d_1),NR_3,NI_3)),E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))),H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))))))).
attacker(cons3(NI_3,NR_3,exp(g,z_1),exp(g,d_1),H(KR_1,(exp(g,d_1),NR_3,NI_3)),E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))),H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))))))).

37. The message SIA_1 that may be sent on channel channelSIA_1 by 4 may be received at input {17}.
So the message emptyset may be sent on channel f_1 at output {62}.
mess(f_1,emptyset).

38. The message (d_1,exp(g,d_1)) may be sent on channel exponent[] at output {7}.
mess(exponent[],(d_1,exp(g,d_1))).

39. The message SIA_1 that may be sent on channel channelSIA_1 by 4 may be received at input {17}.
The message cons3(NI_3,NR_3,exp(g,z_1),exp(g,d_1),H(KR_1,(exp(g,d_1),NR_3,NI_3)),E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))),H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))))))) that the attacker may have by 36 may be received at input {64}.
The message emptyset that may be sent on channel f_1 by 37 may be received at input {67}.
The message (d_1,exp(g,d_1)) that may be sent on channel exponent[] by 38 may be received at input {72}.
So the message d_1 may be sent on channel l_1 at output {73}.
mess(l_1,d_1).

40. We assume as hypothesis that
memberid(Pk(k_4),SIA_1).

41. The message SIA_1 that may be sent on channel channelSIA_1 by 4 may be received at input {17}.
The message cons3(NI_3,NR_3,exp(g,z_1),exp(g,d_1),H(KR_1,(exp(g,d_1),NR_3,NI_3)),E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[])))),H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constI,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(Pk(k_4),saI_2,S(k_4,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(kAminus_1),grpinfoR[]))))))) that the attacker may have by 36 may be received at input {64}.
The message emptyset that may be sent on channel f_1 by 37 may be received at input {67}.
The message d_1 that may be sent on channel l_1 by 39 may be received at input {74}.
By 40, memberid(Pk(k_4),SIA_1) is true at {82}.
So the message cons4(E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR)),H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constR,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR))))) may be sent to the attacker at output {92}.
attacker(cons4(E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR)),H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constR,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR)))))).

42. By 41, the attacker may know cons4(E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR)),H(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagA)),(constR,E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR))))).
Using the function 1-proj-cons4 the attacker may obtain E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR)).
attacker(E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR))).

43. By 27, the attacker may know H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)).
By 42, the attacker may know E(H(exp(exp(g,z_1),d_1),(NI_3,NR_3,tagE)),(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR)).
Using the function D the attacker may obtain (S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR).
attacker((S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR)).

44. By 43, the attacker may know (S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)),saR).
Using the function 1-proj-2-tuple the attacker may obtain S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR)).
attacker(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR))).

45. By 44, attacker(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR))).
The goal is reached, represented in the following fact:
attacker(S(kAminus_1,(NI_3,NR_3,exp(g,z_1),exp(g,d_1),Pk(k_4),saI_2,saR))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new exponent: channel creating exponent_1 at {1}

new honestC: channel creating honestC_1 at {8}

new kAminus: skey creating kAminus_1 at {10} in copy a

new connect: channel creating connect_1 at {12} in copy a

new accept: channel creating accept_1 at {13} in copy a

new init: channel creating init_1 at {14} in copy a

new channelSIA: channel creating channelSIA_1 at {15} in copy a

out(getprinc, (~M,~M_1,~M_2,~M_3,~M_4)) with ~M = Pk(kAminus_1), ~M_1 = init_1, ~M_2 = accept_1, ~M_3 = connect_1, ~M_4 = channelSIA_1 at {16} in copy a

new d: texponent creating d_1 at {3} in copy a_1

out(getexponential, ~M_5) with ~M_5 = exp(g,d_1) at {5} in copy a_1

in(channelSIA_1, a_2) at {17} in copy a

event princ(kAminus_1,Pk(kAminus_1),init_1,accept_1,connect_1,a_2) at {18} in copy a

new KR: key creating KR_1 at {52} in copy a

new f: channel creating f_1 at {61} in copy a

out(exponent_1, (d_1,exp(g,d_1))) at {7} in copy a_1, a_3 received at {54} in copy a, a_4

in(c, cons1(a_5,a_6,a_7)) at {56} in copy a, a_4, a_8

new NR_1: nonce creating NR_3 at {57} in copy a, a_4, a_8

event mess2(Pk(kAminus_1),a_5,NR_3,a_6,exp(g,d_1),grpinfoR,S(kAminus_1,(exp(g,d_1),grpinfoR)),H(KR_1,(exp(g,d_1),NR_3,a_5)),a_7) at {59} in copy a, a_4, a_8

out(c, cons2(~M_6,~M_7,~M_8,~M_9,~M_10,~M_11,~M_12)) with ~M_6 = a_5, ~M_7 = NR_3, ~M_8 = exp(g,d_1), ~M_9 = grpinfoR, ~M_10 = Pk(kAminus_1), ~M_11 = S(kAminus_1,(exp(g,d_1),grpinfoR)), ~M_12 = H(KR_1,(exp(g,d_1),NR_3,a_5)) at {60} in copy a, a_4, a_8

in(c, cons3(a_5,~M_7,exp(g,a_9),~M_5,~M_12,E(H(exp(~M_5,a_9),(a_5,~M_7,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,~M_7,exp(g,a_9),~M_5,~M,grpinfoR)))),H(H(exp(~M_5,a_9),(a_5,~M_7,tagA)),(constI,E(H(exp(~M_5,a_9),(a_5,~M_7,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,~M_7,exp(g,a_9),~M_5,~M,grpinfoR)))))))) with ~M_7 = NR_3, ~M_5 = exp(g,d_1), ~M_12 = H(KR_1,(exp(g,d_1),NR_3,a_5)), E(H(exp(~M_5,a_9),(a_5,~M_7,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,~M_7,exp(g,a_9),~M_5,~M,grpinfoR)))) = E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(kAminus_1),grpinfoR)))), H(H(exp(~M_5,a_9),(a_5,~M_7,tagA)),(constI,E(H(exp(~M_5,a_9),(a_5,~M_7,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,~M_7,exp(g,a_9),~M_5,~M,grpinfoR)))))) = H(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagA)),(constI,E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(kAminus_1),grpinfoR)))))) at {64} in copy a, a_12

event mess3rec(Pk(kAminus_1),a_5,NR_3,exp(g,a_9),exp(g,d_1),H(KR_1,(exp(g,d_1),NR_3,a_5)),E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(kAminus_1),grpinfoR)))),H(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagA)),(constI,E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(kAminus_1),grpinfoR))))))) at {65} in copy a, a_12

out(f_1, emptyset) at {62} in copy a received at {67} in copy a, a_12

new l: channel creating l_1 at {70} in copy a, a_12

out(exponent_1, (d_1,exp(g,d_1))) at {7} in copy a_1, a_13 received at {72} in copy a, a_12, a_14

out(l_1, d_1) at {73} in copy a, a_12, a_14 received at {74} in copy a, a_12

event enddosr(Pk(kAminus_1),a_5,NR_3) at {75} in copy a, a_12

event acceptev(accept_1,Pk(a_10),a_11,saR,H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagV))) at {86} in copy a, a_12

out(accept_1, (~M_13,~M_14,saR,~M_15)) with ~M_13 = Pk(a_10), ~M_14 = a_11, ~M_15 = H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagV)) at {87} in copy a, a_12

event mess4(Pk(kAminus_1),Pk(a_10),E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(S(kAminus_1,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(a_10),a_11,saR)),saR)),H(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagA)),(constR,E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(S(kAminus_1,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(a_10),a_11,saR)),saR)))),a_5,NR_3,exp(g,a_9),exp(g,d_1),H(KR_1,(exp(g,d_1),NR_3,a_5)),E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(kAminus_1),grpinfoR)))),H(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagA)),(constI,E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(Pk(a_10),a_11,S(a_10,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(kAminus_1),grpinfoR))))))) at {91} in copy a, a_12

out(c, cons4(~M_16,~M_17)) with ~M_16 = E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(S(kAminus_1,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(a_10),a_11,saR)),saR)), ~M_17 = H(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagA)),(constR,E(H(exp(exp(g,a_9),d_1),(a_5,NR_3,tagE)),(S(kAminus_1,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(a_10),a_11,saR)),saR)))) at {92} in copy a, a_12

The attacker has the message 1-proj-2-tuple(D(H(exp(~M_5,a_9),(a_5,~M_7,tagE)),~M_16)) = S(kAminus_1,(a_5,NR_3,exp(g,a_9),exp(g,d_1),Pk(a_10),a_11,saR)).
A trace has been found, assuming the following hypothesis:
memberid(Pk(a_10[]),a_2[])
RESULT not attacker(S(kAminus[!1 = v_4],x_1)) cannot be proved.
COMPUTATIONTIME solving_queries (include completion): 0.119198s
NUMBERIMPLIES solving_queries (include completion): 2596

--------------------------------------------------------------
Verification summary:

Query inj-event(enddosi(XIDA,XNI)) ==> (inj-event(mess2rec(XIDA,XNI,XNR,XxR,XgrpinfoR,XIDB,XsR2,XtR,XxI,XIDRp,XsaI)) ==> (inj-event(mess1(XIDA,XNI,XxI,XIDRp,XinitA,Xautorid,XsaI)) ==> inj-event(initev(XinitA,Xautorid,XIDRp,XsaI)))) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) is true.

Query event(acceptev(XacceptB,XIDA,XsaI,XsaR,XKv)) ==> event(princ(XkBminus,XIDB,XinitB,XacceptB,XconnectB,XSIB)) && memberid(XIDA,XSIB) is true.

Query inj-event(connectev(XconnectA,XIDB,XsaI,XsaR,XKv)) ==> inj-event(initev(XinitA,Xautorid,XIDRp,XsaI)) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) && memberid(XIDB,Xautorid) is true.

Query inj-event(connecthonest(XconnectA,XIDB,XsaI,XsaR,XKv)) ==> inj-event(acceptev(XacceptB,XIDA,XsaI,XsaR,XKv)) && event(princ(XkAminus,XIDA,XinitA,XacceptA,XconnectA,XSIA)) && event(princ(XkBminus,XIDB,XinitB,XacceptB,XconnectB,XSIB)) is true.

Query not attacker(S(kAminus[!1 = v_4],x_1)) cannot be proved.

--------------------------------------------------------------

